{"version":3,"file":"vue-slicksort.min.js","sources":["../src/ElementMixin.js","../src/Manager.js","../src/utils.js","../src/ContainerMixin.js","../src/components.js","../src/HandleDirective.js"],"sourcesContent":["// Export Sortable Element Component Mixin\nexport const ElementMixin = {\n  inject: ['manager'],\n  props: {\n    index: {\n      type: Number,\n      required: true,\n    },\n    collection: {\n      type: [String, Number],\n      default: 'default',\n    },\n    disabled: { \n      type: Boolean, \n      default: false,\n    },\n  },\n\n  mounted() {\n    const {collection, disabled, index} = this.$props;\n\n    if (!disabled) {\n      this.setDraggable(collection, index);\n    }\n  },\n\n  watch: {\n    index(newIndex) {\n      if (this.$el && this.$el.sortableInfo) {\n        this.$el.sortableInfo.index = newIndex;\n      }\n    },\n    disabled(isDisabled) {\n      if (isDisabled) {\n        this.removeDraggable(this.collection);\n      } else {\n        this.setDraggable(this.collection, this.index);\n      }\n    },\n    collection(newCollection, oldCollection) {\n      this.removeDraggable(oldCollection);\n      this.setDraggable(newCollection, this.index);\n    },\n  },\n\n  beforeDestroy() {\n    const {collection, disabled} = this;\n\n    if (!disabled) this.removeDraggable(collection);\n  },\n  methods: {\n    setDraggable(collection, index) {\n      const node = this.$el;\n  \n      node.sortableInfo = {\n        index,\n        collection,\n        manager: this.manager,\n      };\n  \n      this.ref = {node};\n      this.manager.add(collection, this.ref);\n    },\n  \n    removeDraggable(collection) {\n      this.manager.remove(collection, this.ref);\n    },\n  },\n};\n","export default class Manager {\n  constructor() {\n    this.refs = {};\n  }\n\n  add(collection, ref) {\n    if (!this.refs[collection]) {\n      this.refs[collection] = [];\n    }\n\n    this.refs[collection].push(ref);\n  }\n\n  remove(collection, ref) {\n    const index = this.getIndex(collection, ref);\n\n    if (index !== -1) {\n      this.refs[collection].splice(index, 1);\n    }\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  getActive() {\n    return this.refs[this.active.collection].find(({node}) => node.sortableInfo.index == this.active.index);\n  }\n\n  getIndex(collection, ref) {\n    return this.refs[collection].indexOf(ref);\n  }\n\n  getOrderedRefs(collection = this.active.collection) {\n    return this.refs[collection].sort((a, b) => {\n      return a.node.sortableInfo.index - b.node.sortableInfo.index;\n    });\n  }\n}\n","export function arrayMove(arr, previousIndex, newIndex) {\n  const array = arr.slice(0);\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length;\n    while (k-- + 1) {\n      array.push(undefined);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n  return array;\n}\n\nexport const events = {\n  start: ['touchstart', 'mousedown'],\n  move: ['touchmove', 'mousemove'],\n  end: ['touchend', 'touchcancel', 'mouseup'],\n};\n\nexport const vendorPrefix = (function() {\n  if (typeof window === 'undefined' || typeof document === 'undefined') return ''; // server environment\n  // fix for:\n  //    https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  //    window.getComputedStyle() returns null inside an iframe with display: none\n  // in this case return an array with a fake mozilla style in it.\n  const styles = window.getComputedStyle(document.documentElement, '') || ['-moz-hidden-iframe'];\n  const pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1];\n\n  switch (pre) {\n    case 'ms':\n      return 'ms';\n    default:\n      return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';\n  }\n})();\n\nexport function closest(el, fn) {\n  while (el) {\n    if (fn(el)) return el;\n    el = el.parentNode;\n  }\n}\n\nexport function limit(min, max, value) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nfunction getCSSPixelValue(stringValue) {\n  if (stringValue.substr(-2) === 'px') {\n    return parseFloat(stringValue);\n  }\n  return 0;\n}\n\nexport function getElementMargin(element) {\n  const style = window.getComputedStyle(element);\n\n  return {\n    top: getCSSPixelValue(style.marginTop),\n    right: getCSSPixelValue(style.marginRight),\n    bottom: getCSSPixelValue(style.marginBottom),\n    left: getCSSPixelValue(style.marginLeft),\n  };\n}\n","import Manager from './Manager';\nimport {\n  closest,\n  events,\n  vendorPrefix,\n  limit,\n  getElementMargin,\n  arrayMove,\n} from './utils';\n\n// Export Sortable Container Component Mixin\nexport const ContainerMixin = {\n  data() {\n    return {\n      sorting: false,\n      sortingIndex: null,\n      manager: new Manager(),\n      events: {\n        start: this.handleStart,\n        move: this.handleMove,\n        end: this.handleEnd,\n      },\n    };\n  },\n\n  props: {\n    value:                      { type: Array,   required: true },\n    axis:                       { type: String,  default: 'y' }, // 'x', 'y', 'xy'\n    distance:                   { type: Number,  default: 0 },\n    pressDelay:                 { type: Number,  default: 0 },\n    pressThreshold:             { type: Number,  default: 5 },\n    useDragHandle:              { type: Boolean, default: false },\n    useWindowAsScrollContainer: { type: Boolean, default: false },\n    hideSortableGhost:          { type: Boolean, default: true },\n    lockToContainerEdges:       { type: Boolean, default: false },\n    lockOffset:                 { type: [String, Number, Array], default: '50%' },\n    transitionDuration:         { type: Number,  default: 300 },\n    appendTo:                   { type: String,  default: 'body' },\n    draggedSettlingDuration:    { type: Number,  default: null },\n    lockAxis: String,\n    helperClass: String,\n    contentWindow: Object,\n    shouldCancelStart: { \n      type: Function, \n      default: (e) => {\n        // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`\n        const disabledElements = ['input', 'textarea', 'select', 'option', 'button'];\n        return disabledElements.indexOf(e.target.tagName.toLowerCase()) !== -1;\n      },\n    },\n    getHelperDimensions: { \n      type: Function,\n      default: ({node}) => ({\n        width: node.offsetWidth,\n        height: node.offsetHeight,\n      }),\n    },\n  },\n\n  provide() {\n    return {\n      manager: this.manager,\n    };\n  },\n\n  mounted() {\n    this.container = this.$el;\n    this.document = this.container.ownerDocument || document;\n    this._window = this.contentWindow || window;\n    this.scrollContainer = this.useWindowAsScrollContainer\n      ? this.document.body\n      : this.container;\n\n    for (const key in this.events) {\n      if (this.events.hasOwnProperty(key)) {\n        events[key].forEach(eventName =>\n          this.container.addEventListener(eventName, this.events[key], false)\n        );\n      }\n    }\n  },\n\n  beforeDestroy() {\n    for (const key in this.events) {\n      if (this.events.hasOwnProperty(key)) {\n        events[key].forEach(eventName =>\n          this.container.removeEventListener(eventName, this.events[key])\n        );\n      }\n    }\n  },\n\n  methods: {\n\n    handleStart(e) {\n      const {distance, shouldCancelStart} = this.$props;\n\n      if (e.button === 2 || shouldCancelStart(e)) {\n        return false;\n      }\n\n      this._touched = true;\n      this._pos = this.getOffset(e);\n\n      const node = closest(e.target, el => el.sortableInfo != null);\n\n      if (\n        node &&\n        node.sortableInfo &&\n        this.nodeIsChild(node) &&\n        !this.sorting\n      ) {\n        const {useDragHandle} = this.$props;\n        const {index, collection} = node.sortableInfo;\n\n        if (\n          useDragHandle && !closest(e.target, el => el.sortableHandle != null)\n        )\n          return;\n\n        this.manager.active = {index, collection};\n\n        /*\n\t\t\t\t * Fixes a bug in Firefox where the :active state of anchor tags\n\t\t\t\t * prevent subsequent 'mousemove' events from being fired\n\t\t\t\t * (see https://github.com/clauderic/react-sortable-hoc/issues/118)\n\t\t\t\t */\n        if (e.target.tagName.toLowerCase() === 'a') {\n          e.preventDefault();\n        }\n\n        if (!distance) {\n          if (this.$props.pressDelay === 0) {\n            this.handlePress(e);\n          } else {\n            this.pressTimer = setTimeout(\n              () => this.handlePress(e),\n              this.$props.pressDelay\n            );\n          }\n        }\n      }\n    },\n\n    nodeIsChild(node) {\n      return node.sortableInfo.manager === this.manager;\n    },\n\n    handleMove(e) {\n      const {distance, pressThreshold} = this.$props;\n\n      if (!this.sorting && this._touched) {\n        const offset = this.getOffset(e);\n        this._delta = {\n          x: this._pos.x - offset.x,\n          y: this._pos.y - offset.y,\n        };\n        const delta = Math.abs(this._delta.x) + Math.abs(this._delta.y);\n\n        if (!distance && (!pressThreshold || pressThreshold && delta >= pressThreshold)) {\n          clearTimeout(this.cancelTimer);\n          this.cancelTimer = setTimeout(this.cancel, 0);\n        } else if (distance && delta >= distance && this.manager.isActive()) {\n          this.handlePress(e);\n        }\n      }\n    },\n\n    handleEnd() {\n      const {distance} = this.$props;\n\n      this._touched = false;\n\n      if (!distance) {\n        this.cancel();\n      }\n    },\n\n    cancel() {\n      if (!this.sorting) {\n        clearTimeout(this.pressTimer);\n        this.manager.active = null;\n      }\n    },\n\n    handlePress(e) {\n      const active = this.manager.getActive();\n\n      if (active) {\n        const {\n          axis,\n          getHelperDimensions,\n          helperClass,\n          hideSortableGhost,\n          useWindowAsScrollContainer,\n          appendTo,\n        } = this.$props;\n        const {node, collection} = active;\n        const {index} = node.sortableInfo;\n        const margin = getElementMargin(node);\n\n        const containerBoundingRect = this.container.getBoundingClientRect();\n        const dimensions = getHelperDimensions({index, node, collection});\n\n        this.node = node;\n        this.margin = margin;\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.marginOffset = {\n          x: this.margin.left + this.margin.right,\n          y: Math.max(this.margin.top, this.margin.bottom),\n        };\n        this.boundingClientRect = node.getBoundingClientRect();\n        this.containerBoundingRect = containerBoundingRect;\n        this.index = index;\n        this.newIndex = index;\n\n        this._axis = {\n          x: axis.indexOf('x') >= 0,\n          y: axis.indexOf('y') >= 0,\n        };\n        this.offsetEdge = this.getEdgeOffset(node);\n        this.initialOffset = this.getOffset(e);\n        this.initialScroll = {\n          top: this.scrollContainer.scrollTop,\n          left: this.scrollContainer.scrollLeft,\n        };\n\n        this.initialWindowScroll = {\n          top: window.pageYOffset,\n          left: window.pageXOffset,\n        };\n\n        const fields = node.querySelectorAll('input, textarea, select');\n        const clonedNode = node.cloneNode(true);\n        const clonedFields = [\n          ...clonedNode.querySelectorAll('input, textarea, select'),\n        ]; // Convert NodeList to Array\n\n        clonedFields.forEach((field, index) => {\n          if (field.type !== 'file' && fields[index]) {\n            field.value = fields[index].value;\n          }\n        });\n\n        this.helper = this.document.querySelector(appendTo).appendChild(clonedNode);\n\n        this.helper.style.position = 'fixed';\n        this.helper.style.top = `${this.boundingClientRect.top - margin.top}px`;\n        this.helper.style.left = `${this.boundingClientRect.left - margin.left}px`;\n        this.helper.style.width = `${this.width}px`;\n        this.helper.style.height = `${this.height}px`;\n        this.helper.style.boxSizing = 'border-box';\n        this.helper.style.pointerEvents = 'none';\n\n        if (hideSortableGhost) {\n          this.sortableGhost = node;\n          node.style.visibility = 'hidden';\n          node.style.opacity = 0;\n        }\n\n        this.translate = {};\n        this.minTranslate = {};\n        this.maxTranslate = {};\n        if (this._axis.x) {\n          this.minTranslate.x = (useWindowAsScrollContainer\n            ? 0\n            : containerBoundingRect.left) -\n            this.boundingClientRect.left -\n            this.width / 2;\n          this.maxTranslate.x = (useWindowAsScrollContainer\n            ? this._window.innerWidth\n            : containerBoundingRect.left + containerBoundingRect.width) -\n            this.boundingClientRect.left -\n            this.width / 2;\n        }\n        if (this._axis.y) {\n          this.minTranslate.y = (useWindowAsScrollContainer\n            ? 0\n            : containerBoundingRect.top) -\n            this.boundingClientRect.top -\n            this.height / 2;\n          this.maxTranslate.y = (useWindowAsScrollContainer\n            ? this._window.innerHeight\n            : containerBoundingRect.top + containerBoundingRect.height) -\n            this.boundingClientRect.top -\n            this.height / 2;\n        }\n\n        if (helperClass) {\n          this.helper.classList.add(...helperClass.split(' '));\n        }\n\n        this.listenerNode = e.touches ? node : this._window;\n        events.move.forEach(eventName =>\n          this.listenerNode.addEventListener(\n            eventName,\n            this.handleSortMove,\n            false\n          ));\n        events.end.forEach(eventName =>\n          this.listenerNode.addEventListener(\n            eventName,\n            this.handleSortEnd,\n            false\n          ));\n\n        this.sorting = true;\n        this.sortingIndex = index;\n\n        this.$emit('sort-start', {event: e, node, index, collection});\n      }\n    },\n\n    handleSortMove(e) {\n      e.preventDefault(); // Prevent scrolling on mobile\n\n      this.updatePosition(e);\n      this.animateNodes();\n      this.autoscroll();\n\n      this.$emit('sort-move', { event: e });\n    },\n\n    handleSortEnd(e) {\n      const {collection} = this.manager.active;\n\n      // Remove the event listeners if the node is still in the DOM\n      if (this.listenerNode) {\n        events.move.forEach(eventName =>\n          this.listenerNode.removeEventListener(\n            eventName,\n            this.handleSortMove\n          ));\n        events.end.forEach(eventName =>\n          this.listenerNode.removeEventListener(eventName, this.handleSortEnd));\n      }\n\n      const nodes = this.manager.refs[collection];\n\n      const onEnd = () => {\n        // Remove the helper from the DOM\n        this.helper.parentNode.removeChild(this.helper);\n\n        if (this.hideSortableGhost && this.sortableGhost) {\n          this.sortableGhost.style.visibility = '';\n          this.sortableGhost.style.opacity = '';\n        }\n\n        for (let i = 0, len = nodes.length; i < len; i++) {\n          const node = nodes[i];\n          const el = node.node;\n\n          // Clear the cached offsetTop / offsetLeft value\n          node.edgeOffset = null;\n\n          // Remove the transforms / transitions\n          el.style[`${vendorPrefix}Transform`] = '';\n          el.style[`${vendorPrefix}TransitionDuration`] = '';\n        }\n\n        // Stop autoscroll\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n\n        // Update state\n        this.manager.active = null;\n\n        this.sorting = false;\n        this.sortingIndex = null;\n\n        this.$emit('sort-end', {\n          event: e,\n          oldIndex: this.index,\n          newIndex: this.newIndex,\n          collection,\n        });\n        this.$emit('input', arrayMove(this.value, this.index, this.newIndex));\n\n        this._touched = false;\n      };\n\n      if (this.$props.transitionDuration || this.$props.draggedSettlingDuration) {\n        this.transitionHelperIntoPlace(nodes).then(() => onEnd());\n      } else {\n        onEnd();\n      }\n\n    },\n\n    transitionHelperIntoPlace(nodes) {\n      if (this.$props.draggedSettlingDuration === 0) {\n        return Promise.resolve();\n      }\n\n      const deltaScroll = {\n        left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n        top: this.scrollContainer.scrollTop - this.initialScroll.top,\n      };\n      const indexNode = nodes[this.index].node;\n      const newIndexNode = nodes[this.newIndex].node;\n\n      let targetX = -deltaScroll.left;\n      if (this.translate && this.translate.x > 0) {\n        // Diff against right edge when moving to the right\n        targetX += newIndexNode.offsetLeft + newIndexNode.offsetWidth -\n          (indexNode.offsetLeft + indexNode.offsetWidth);\n      } else {\n        targetX += newIndexNode.offsetLeft - indexNode.offsetLeft;\n      }\n\n      let targetY = -deltaScroll.top;\n      if (this.translate && this.translate.y > 0) {\n        // Diff against the bottom edge when moving down\n        targetY += newIndexNode.offsetTop + newIndexNode.offsetHeight -\n          (indexNode.offsetTop + indexNode.offsetHeight);\n      } else {\n        targetY += newIndexNode.offsetTop - indexNode.offsetTop;\n      }\n\n      const duration = this.$props.draggedSettlingDuration !== null\n        ? this.$props.draggedSettlingDuration\n        : this.$props.transitionDuration;\n\n      this.helper.style[`${vendorPrefix}Transform`] = `translate3d(${targetX}px,${targetY}px, 0)`;\n      this.helper.style[\n        `${vendorPrefix}TransitionDuration`\n      ] = `${duration}ms`;\n\n      return new Promise(resolve => {\n        // Register an event handler to clean up styles when the transition\n        // finishes.\n        const cleanup = event => {\n          if (!event || event.propertyName === 'transform') {\n            clearTimeout(cleanupTimer);\n            this.helper.style[`${vendorPrefix}Transform`] = '';\n            this.helper.style[`${vendorPrefix}TransitionDuration`] = '';\n            resolve();\n          }\n        };\n        // Force cleanup in case 'transitionend' never fires\n        const cleanupTimer = setTimeout(cleanup, duration + 10);\n        this.helper.addEventListener('transitionend', cleanup, false);\n      });\n    },\n\n    getEdgeOffset(node, offset = {top: 0, left: 0}) {\n      // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n      if (node) {\n        const nodeOffset = {\n          top: offset.top + node.offsetTop,\n          left: offset.left + node.offsetLeft,\n        };\n        if (node.parentNode !== this.container) {\n          return this.getEdgeOffset(node.parentNode, nodeOffset);\n        } else {\n          return nodeOffset;\n        }\n      }\n    },\n\n    getOffset(e) {\n      const { pageX, pageY } = e.touches ? e.touches[0] : e;\n      return {\n        x: pageX,\n        y: pageY,\n      };\n    },\n\n    getLockPixelOffsets() {\n      let {lockOffset} = this.$props;\n\n      if (!Array.isArray(this.lockOffset)) {\n        lockOffset = [lockOffset, lockOffset];\n      }\n\n      if (lockOffset.length !== 2) {\n        throw new Error(`lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given ${lockOffset}`);\n      }\n\n      const [minLockOffset, maxLockOffset] = lockOffset;\n\n      return [\n        this.getLockPixelOffset(minLockOffset),\n        this.getLockPixelOffset(maxLockOffset),\n      ];\n    },\n\n    getLockPixelOffset(lockOffset) {\n      let offsetX = lockOffset;\n      let offsetY = lockOffset;\n      let unit = 'px';\n\n      if (typeof lockOffset === 'string') {\n        const match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n\n        if (match === null) {\n          throw new Error(`lockOffset value should be a number or a string of a number followed by \"px\" or \"%\". Given ${lockOffset}`);\n        }\n\n        offsetX = (offsetY = parseFloat(lockOffset));\n        unit = match[1];\n      }\n\n      if (!isFinite(offsetX) || !isFinite(offsetY)) {\n        throw new Error(`lockOffset value should be a finite. Given ${lockOffset}`);\n      }\n\n      if (unit === '%') {\n        offsetX = offsetX * this.width / 100;\n        offsetY = offsetY * this.height / 100;\n      }\n\n      return {\n        x: offsetX,\n        y: offsetY,\n      };\n    },\n\n    updatePosition(e) {\n      const {lockAxis, lockToContainerEdges} = this.$props;\n\n      const offset = this.getOffset(e);\n      const translate = {\n        x: offset.x - this.initialOffset.x,\n        y: offset.y - this.initialOffset.y,\n      };\n      // Adjust for window scroll\n      translate.y -= (window.pageYOffset - this.initialWindowScroll.top);\n      translate.x -= (window.pageXOffset - this.initialWindowScroll.left);\n\n      this.translate = translate;\n\n      if (lockToContainerEdges) {\n        const [minLockOffset, maxLockOffset] = this.getLockPixelOffsets();\n        const minOffset = {\n          x: this.width / 2 - minLockOffset.x,\n          y: this.height / 2 - minLockOffset.y,\n        };\n        const maxOffset = {\n          x: this.width / 2 - maxLockOffset.x,\n          y: this.height / 2 - maxLockOffset.y,\n        };\n\n        translate.x = limit(\n          this.minTranslate.x + minOffset.x,\n          this.maxTranslate.x - maxOffset.x,\n          translate.x\n        );\n        translate.y = limit(\n          this.minTranslate.y + minOffset.y,\n          this.maxTranslate.y - maxOffset.y,\n          translate.y\n        );\n      }\n\n      if (lockAxis === 'x') {\n        translate.y = 0;\n      } else if (lockAxis === 'y') {\n        translate.x = 0;\n      }\n\n      this.helper.style[\n        `${vendorPrefix}Transform`\n      ] = `translate3d(${translate.x}px,${translate.y}px, 0)`;\n    },\n\n    animateNodes() {\n      const {transitionDuration, hideSortableGhost} = this.$props;\n      const nodes = this.manager.getOrderedRefs();\n      const deltaScroll = {\n        left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n        top: this.scrollContainer.scrollTop - this.initialScroll.top,\n      };\n      const sortingOffset = {\n        left: this.offsetEdge.left + this.translate.x + deltaScroll.left,\n        top: this.offsetEdge.top + this.translate.y + deltaScroll.top,\n      };\n      const scrollDifference = {\n        top: (window.pageYOffset - this.initialWindowScroll.top),\n        left: (window.pageXOffset - this.initialWindowScroll.left),\n      };\n      this.newIndex = null;\n\n      for (let i = 0, len = nodes.length; i < len; i++) {\n        const {node} = nodes[i];\n        const index = node.sortableInfo.index;\n        const width = node.offsetWidth;\n        const height = node.offsetHeight;\n        const offset = {\n          width: this.width > width ? width / 2 : this.width / 2,\n          height: this.height > height ? height / 2 : this.height / 2,\n        };\n\n        const translate = {\n          x: 0,\n          y: 0,\n        };\n        let {edgeOffset} = nodes[i];\n\n        // If we haven't cached the node's offsetTop / offsetLeft value\n        if (!edgeOffset) {\n          nodes[i].edgeOffset = (edgeOffset = this.getEdgeOffset(node));\n        }\n\n        // Get a reference to the next and previous node\n        const nextNode = i < nodes.length - 1 && nodes[i + 1];\n        const prevNode = i > 0 && nodes[i - 1];\n\n        // Also cache the next node's edge offset if needed.\n        // We need this for calculating the animation in a grid setup\n        if (nextNode && !nextNode.edgeOffset) {\n          nextNode.edgeOffset = this.getEdgeOffset(nextNode.node);\n        }\n\n        // If the node is the one we're currently animating, skip it\n        if (index === this.index) {\n          if (hideSortableGhost) {\n            /*\n\t\t\t\t\t\t * With windowing libraries such as `react-virtualized`, the sortableGhost\n\t\t\t\t\t\t * node may change while scrolling down and then back up (or vice-versa),\n\t\t\t\t\t\t * so we need to update the reference to the new node just to be safe.\n\t\t\t\t\t\t */\n            this.sortableGhost = node;\n            node.style.visibility = 'hidden';\n            node.style.opacity = 0;\n          }\n          continue;\n        }\n\n        if (transitionDuration) {\n          node.style[\n            `${vendorPrefix}TransitionDuration`\n          ] = `${transitionDuration}ms`;\n        }\n\n        if (this._axis.x) {\n          if (this._axis.y) {\n            // Calculations for a grid setup\n            if (\n              index < this.index &&\n              (\n                ((sortingOffset.left + scrollDifference.left) - offset.width <= edgeOffset.left &&\n                (sortingOffset.top + scrollDifference.top) <= edgeOffset.top + offset.height) ||\n                (sortingOffset.top + scrollDifference.top) + offset.height <= edgeOffset.top\n              )\n            ) {\n              // If the current node is to the left on the same row, or above the node that's being dragged\n              // then move it to the right\n              translate.x = this.width + this.marginOffset.x;\n              if (\n                edgeOffset.left + translate.x >\n                this.containerBoundingRect.width - offset.width\n              ) {\n                // If it moves passed the right bounds, then animate it to the first position of the next row.\n                // We just use the offset of the next node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = nextNode.edgeOffset.left - edgeOffset.left;\n                translate.y = nextNode.edgeOffset.top - edgeOffset.top;\n              }\n              if (this.newIndex === null) {\n                this.newIndex = index;\n              }\n            } else if (\n              index > this.index &&\n              (\n                ((sortingOffset.left + scrollDifference.left) + offset.width >= edgeOffset.left &&\n                (sortingOffset.top + scrollDifference.top) + offset.height >= edgeOffset.top) ||\n                (sortingOffset.top + scrollDifference.top) + offset.height >= edgeOffset.top + height\n              )\n            ) {\n              // If the current node is to the right on the same row, or below the node that's being dragged\n              // then move it to the left\n              translate.x = -(this.width + this.marginOffset.x);\n              if (\n                edgeOffset.left + translate.x <\n                this.containerBoundingRect.left + offset.width\n              ) {\n                // If it moves passed the left bounds, then animate it to the last position of the previous row.\n                // We just use the offset of the previous node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = prevNode.edgeOffset.left - edgeOffset.left;\n                translate.y = prevNode.edgeOffset.top - edgeOffset.top;\n              }\n              this.newIndex = index;\n            }\n          } else {\n            if (\n              index > this.index &&\n              (sortingOffset.left + scrollDifference.left) + offset.width >= edgeOffset.left\n            ) {\n              translate.x = -(this.width + this.marginOffset.x);\n              this.newIndex = index;\n            } else if (\n              index < this.index &&\n              (sortingOffset.left + scrollDifference.left) <= edgeOffset.left + offset.width\n            ) {\n              translate.x = this.width + this.marginOffset.x;\n              if (this.newIndex == null) {\n                this.newIndex = index;\n              }\n            }\n          }\n        } else if (this._axis.y) {\n          if (\n            index > this.index &&\n            (sortingOffset.top + scrollDifference.top) + offset.height >= edgeOffset.top\n          ) {\n            translate.y = -(this.height + this.marginOffset.y);\n            this.newIndex = index;\n          } else if (\n            index < this.index &&\n            (sortingOffset.top + scrollDifference.top) <= edgeOffset.top + offset.height\n          ) {\n            translate.y = this.height + this.marginOffset.y;\n            if (this.newIndex == null) {\n              this.newIndex = index;\n            }\n          }\n        }\n        node.style[`${vendorPrefix}Transform`] = `translate3d(${translate.x}px,${translate.y}px,0)`;\n      }\n\n      if (this.newIndex == null) {\n        this.newIndex = this.index;\n      }\n    },\n\n    autoscroll() {\n      const translate = this.translate;\n      const direction = {\n        x: 0,\n        y: 0,\n      };\n      const speed = {\n        x: 1,\n        y: 1,\n      };\n      const acceleration = {\n        x: 10,\n        y: 10,\n      };\n\n      if (translate.y >= this.maxTranslate.y - this.height / 2) {\n        direction.y = 1; // Scroll Down\n        speed.y = acceleration.y * Math.abs((this.maxTranslate.y - this.height / 2 - translate.y) / this.height);\n      } else if (translate.x >= this.maxTranslate.x - this.width / 2) {\n        direction.x = 1; // Scroll Right\n        speed.x = acceleration.x * Math.abs((this.maxTranslate.x - this.width / 2 - translate.x) / this.width);\n      } else if (translate.y <= this.minTranslate.y + this.height / 2) {\n        direction.y = -1; // Scroll Up\n        speed.y = acceleration.y * Math.abs((translate.y - this.height / 2 - this.minTranslate.y) / this.height);\n      } else if (translate.x <= this.minTranslate.x + this.width / 2) {\n        direction.x = -1; // Scroll Left\n        speed.x = acceleration.x * Math.abs((translate.x - this.width / 2 - this.minTranslate.x) / this.width);\n      }\n\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n        this.isAutoScrolling = false;\n      }\n\n      if (direction.x !== 0 || direction.y !== 0) {\n        this.autoscrollInterval = setInterval(\n          () => {\n            this.isAutoScrolling = true;\n            const offset = {\n              left: 1 * speed.x * direction.x,\n              top: 1 * speed.y * direction.y,\n            };\n            this.scrollContainer.scrollTop += offset.top;\n            this.scrollContainer.scrollLeft += offset.left;\n            this.translate.x += offset.left;\n            this.translate.y += offset.top;\n            this.animateNodes();\n          },\n          5\n        );\n      }\n    },\n  },\n};\n","import { ElementMixin } from './ElementMixin';\nimport { ContainerMixin } from './ContainerMixin';\n\nexport const SlickList = {\n  name: 'slick-list',\n  mixins: [ ContainerMixin ],\n  render (h) {\n    return h('div', this.$slots.default);\n  },\n};\n\nexport const SlickItem = {\n  name: 'slick-item',\n  mixins: [ ElementMixin ],\n  render (h) {\n    return h('div', this.$slots.default);\n  },\n};\n","// Export Sortable Element Handle Directive\nexport const HandleDirective = {\n  bind(el) {\n    el.sortableHandle = true;\n  },\n};\n"],"names":["ElementMixin","Number","String","Boolean","this","$props","collection","disabled","index","setDraggable","newIndex","$el","sortableInfo","isDisabled","removeDraggable","newCollection","oldCollection","node","manager","ref","add","remove","Manager","refs","push","getIndex","splice","active","find","_this","indexOf","sort","a","b","arrayMove","arr","previousIndex","array","slice","length","k","undefined","events","vendorPrefix","window","document","styles","getComputedStyle","documentElement","pre","Array","prototype","call","join","match","OLink","toUpperCase","substr","closest","el","fn","parentNode","limit","min","max","value","getCSSPixelValue","stringValue","parseFloat","ContainerMixin","handleStart","handleMove","handleEnd","type","required","default","Object","Function","e","target","tagName","toLowerCase","offsetWidth","offsetHeight","container","ownerDocument","_window","contentWindow","scrollContainer","useWindowAsScrollContainer","body","key","hasOwnProperty","forEach","addEventListener","eventName","_this2","removeEventListener","distance","shouldCancelStart","button","_touched","_pos","getOffset","nodeIsChild","sorting","useDragHandle","sortableHandle","preventDefault","pressDelay","handlePress","pressTimer","setTimeout","_this3","pressThreshold","offset","_delta","x","y","delta","Math","abs","isActive","cancelTimer","cancel","helperClass","hideSortableGhost","appendTo","dimensions","fields","clonedNode","element","getActive","axis","getHelperDimensions","margin","style","marginTop","marginRight","marginBottom","marginLeft","containerBoundingRect","getBoundingClientRect","width","height","marginOffset","left","right","top","bottom","boundingClientRect","_axis","offsetEdge","getEdgeOffset","initialOffset","initialScroll","scrollTop","scrollLeft","initialWindowScroll","pageYOffset","pageXOffset","querySelectorAll","cloneNode","field","helper","querySelector","appendChild","position","boxSizing","pointerEvents","sortableGhost","visibility","opacity","translate","minTranslate","maxTranslate","innerWidth","innerHeight","classList","split","listenerNode","touches","move","_this4","handleSortMove","end","handleSortEnd","sortingIndex","$emit","event","updatePosition","animateNodes","autoscroll","_this5","onEnd","removeChild","i","len","nodes","edgeOffset","autoscrollInterval","transitionDuration","draggedSettlingDuration","transitionHelperIntoPlace","then","Promise","resolve","deltaScroll","indexNode","newIndexNode","targetX","offsetLeft","targetY","offsetTop","duration","cleanup","propertyName","cleanupTimer","nodeOffset","pageX","pageY","lockOffset","isArray","Error","minLockOffset","maxLockOffset","getLockPixelOffset","offsetX","offsetY","unit","exec","isFinite","lockAxis","lockToContainerEdges","getLockPixelOffsets","minOffset","maxOffset","getOrderedRefs","sortingOffset","scrollDifference","nextNode","prevNode","direction","speed","acceleration","isAutoScrolling","setInterval","SlickList","h","$slots","SlickItem"],"mappings":"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"}